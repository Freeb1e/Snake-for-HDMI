# FPGA贪吃蛇
## 项目简介
贪吃蛇是一个经典又十分有趣的小游戏，简单的规则和富有操作性的体验给很多人都留下了深
刻的影响。本次课程设计中，我们使用了ZYNQ7020 开发板驱动显示器在1920×1080@60Hz 的显
示模式下来进行了对于这个游戏的复刻。完成了从游戏运行逻辑、人机触屏交互、HDMI 显示器驱
动在FPGA 资源部分的实现。并在最基本的规则上添加了分数显示、难度选择等功能。
## 模块设计
### 基本游戏逻辑的实现
#### 分频器模块
将系统时钟clk(50MHz) 进行分频得到clk_move 信号，该信号用于控制每一次贪吃蛇位置的
刷新。同时通过调节分频计数器DIVISOR 的大小，就可以实现控制蛇身移动速度，改变游戏难度
的效果。

#### 蛇身移动逻辑（顶层模块中实现）
考虑到FPGA 并行逻辑的特性，直接定义能够存储20 节蛇身位置的寄存器组，并在复位时候
进行位置初始化。在移动的时候只需要确定出蛇头的位置，接下来的坐标就可以通过类似移位的方
式进行确定。该模块使用分频之后的clk_move 时钟信号来控制刷新。
#### gameover 逻辑（顶层模块中实现）
在游戏的过程中存在两种情况会导致游戏失败，一种情况是蛇头与蛇身发生碰撞，还有一种是
碰到了地图周围的墙壁。因此我们定义了两个信号gameover_self 和gameover_wall 来分别标志这
两种情况。并且根据游戏的难度选择进行适时的启用与屏蔽。在后续的改进过程中，我们将障碍物
的判断整合进了蛇身移动模块当中，而将蛇的自身碰撞判断独立书写。
#### 食物产生模块
在游戏的过程中，每当食物被吃掉之后，就需要在地图的随机位置产生一个新的食物。为了得
到随机性较强的序列，我们使用一个独立的module 引入线性反馈移位寄存器（LFSR）来生成伪随
机数以备调用。它能够在每一个clk 时钟的触发沿提供一个新的随机坐标。在得到需要刷新的指令
gen_flag 信号之后，当即开始进行坐标的校验，如果坐标与蛇身的位置已经重合了则重新取用。由
于两次蛇身移动的信号clk_move 之间存在多个clk 边沿，因此可以保证能够得到符合要求的食物
位置。同时，因为伪随机序列本身的长度较长、抽取随机数的时间也就是玩家操作蛇吃到果实的时
间是随机的，经过实践，能够起到很好的随机生成效果。
#### 游戏控制状态机
游戏的过程中，玩家对于游戏内容的控制信号来源于由串口连接的串口屏（通信部分后文介
绍）。在收到来自串口的信号之后，除了可以实现对于正常游戏中的方向改变，还加入了更改难度、
控制启停、复位等功能。
难度等级内容变化实现方式
简单无边界围墙、速度慢DIVISOR<=25000000;wall<=0;
进阶无边界围墙、速度加快DIVISOR<=15000000;wall<=0;
困难存在边界围墙、速度慢DIVISOR<=25000000;wall<=1;
特别困难存在边界围墙、速度加快DIVISOR<=15000000;wall<=1;
uart_rx_data(十进制量) 指标变化操作目的
UP(1),LEFT(2),
direction,last_direction 改变蛇头运行方向
DOWN(3),RIGHT(4)
MODE1(5),MODE2(8),
mode 更改游戏难度模式
MODE3(9),MODE4(10)
START(5) pause,rst1 控制游戏开始
PAUSE(6) pause 控制游戏暂停
AGAIN(11) rst1,pause,directon,last_direction 重新开始游戏
### HDMI 显示驱动的实现
#### 使用PLL 资源得到所需时钟
晶振端口的输入时钟clk 仅有50Mhz，不能够满足显示内容产生时候的像素时钟与HDMI 进
行串行传输时高频时钟。因此我们调用了开发板上自带的锁相环资源，利用50MHz 的输入用于产
生像素时钟clk1x 与用于串行传输的时钟clk5x。
#### 同步信号的设计
常见的彩色显示器一般由CRT（阴极射线管）构成，色彩是由R、G、B（红、黄、蓝）三基
色组成。显示是用逐行扫描的方式解决，阴极射线枪发出电子束打在涂有荧光粉的荧光屏上，产生
RGB 三基色，合成一个彩色像素。扫描从屏幕的左上方开始，从左到右，从上到下，进行扫描，每
扫完一行，电子束回到屏幕的左边下一行的起始位置，在这其间CRT 对电子束进行消隐。每行结
束时，用行同步信号进行同步；扫描完所有行，用场同步信号进行同步，并使扫描回到屏幕左上方，
同时进行场消隐，预备下一场的扫描。
因此，对于VGA 显示器，共有5 个信号：R、G、B 三基色；HS（行同步信号）；VS（场同步信号）。
对于时序驱动，VGA 显示器要严格遵循“VGA”工业标准，本工程选取分辨率为1920x1080@60Hz
模式。

名称数值
H_TOTAL 一行总共需要计数的值2200-1
H_SYNC 行同步计数值44-1
H_START 行图像数据有效开始计数值190-1
H_END 行图像数据有效结束计数值210-1
V_TOTAL 场总共需要计数的值1125-1
V_SYNC 场同步计数值5-1
V_START 场图像数据有效开始计数值41-1
V_END 场图像数据有效结束计数值1121-1
行计数器、场计数器符合VGA 时序，即水平扫描时进行行计数，竖直扫描进行场计数。
行计数器（cnt_h）: 在每个时钟脉冲上，行计数器(cnt_h) 递增，直到达到设定的总行数
(H_TOTAL) 时清零。
1 always @(posedge vpg_pclk ) begin
2 if (rst ==1'b1) begin
3 cnt_h <= 'd0;
4 end
5 else if (cnt_h == H_TOTAL) begin // 计数到最大值， 清零
6 cnt_h <= 'd0;
7 end
8 else if(cnt_h != H_TOTAL) begin // 还没有计数到最大值， 每个时钟周期加一
9 cnt_h <= cnt_h + 1'b1;
10 end
11 end
8

场计数器（cnt_v）：在每个时钟脉冲上，场计数器(cnt_v) 在每行扫描结束时递增，直到达到
设定的总场数(V_TOTAL) 时清零。
1 always @(posedge vpg_pclk ) begin
2 if (rst ==1'b1) begin
3 cnt_h <= 'd0;
4 end
5 else if (cnt_h == H_TOTAL) begin // 计数到最大值， 清零
6 cnt_h <= 'd0;
7 end
8 else if(cnt_h != H_TOTAL) begin // 还没有计数到最大值， 每个时钟周期加一
9 cnt_h <= cnt_h + 1'b1;
10 end
11 end
有了行计数器（cnt_h）和场计数器（cnt_v），这两个计数器可以用来确定当前正在显示的像素位
置，H_START<=cnt_h<H_END,V_START<=cnt_v<V_END，这是有效显示页面的位置，选
择不同范围的cnt_h 与cnt_v 组合，则选择了不同区域，此时设置rgb 的大小则可以决定此区域
显示的颜色。例如当难度设置较难时，游戏增加了边框，对于边框的显示，代码为：
1 if (( cnt_h < H_START +340+ BORDER || cnt_h >= H_END - BORDER) || // 左右边框
2 (cnt_v < V_START + BORDER || cnt_v >= V_END - BORDER)) begin // 上下边框
3 if(mode >2'd1)begin rgb <= 24'hFF0000; end
4 else if(mode <=2'd1)begin rgb <=24' h0000FF; end
5 else begin rgb <=24'd0; end
6 end
9
3.2.3 蛇身映射逻辑
在设计蛇的移动逻辑过程中，我们将整个可供移动的空间划分成为了30×20 的表格。在显示
的过程中我们需要将这个表格映射到屏幕上实际显示的像素点上面。因此我们设计了一个多重计数
的程序进行实现。
如下图所示进行计数，使用cnt_50_row 和cnt_50_col 进行行列50 个的计数，然后再用他们
作为信号进行Raw 和Col 的计数，就可以得到具体像素在20×30 表格中的位置进而确定颜色了。
具体执行进位的过程如下：
1. 首先由cnt_50_row 记录出50 个横向像素，对Row 计数进行进位。
2. 当row 计数达到30 的时候，说明完成了一个像素行的显示，对cnt_50_col 进行进位。
3. 当cnt_50_col 完成的时候，说明已经完成了纵向的50 个像素行的刷新，50×50×30 的像素
点传输已经完成，这个时候对col 进行进位，说明已经完成了蛇坐标方格中的一行，这个时候对col
进行进位开始绘制下一行。
4.col 计数绘制完19 行，最后一次进位信号到来之后，说明一帧画面中蛇运动空间的的绘制过
程已经结束。下面是计数器的主要部分：
图14: 坐标映射计数器计数原理
1 always@(posedge vpg_pclk)begin
2 if((rst==1'b1)||(vpg_vs==1'b1))begin
3 row<=5'b0;
4 col<=5'b0;
5 cnt_50_raw<=6'd0;
6 cnt_50_col<=6'd0;
7 end
8 else if(!(cnt_h<=400||cnt_h>1900||cnt_v<=81||cnt_v>1081)) begin
9 if(cnt_50_raw==49)begin//如果横向走过了50个像素，开始改变映射的横坐标
10 cnt_50_raw <= 6'b0;//先清零计数器
11 if(row==29)begin//如果已经走到了最后一行，那么行的计数重新开始，并且在纵向向下移动一个像素
12 row <= 5'b0;
13 if(cnt_50_col==49)begin//如果纵向走过了50个像素，则需要改变映射的纵坐标
14 cnt_50_col <= 6'b0;
15 if(col==29)begin//如果已经走到了最后一列，则列的计数重新开始
16 col<=5'b0;
10
李远政、刘振豪华中科技大学数字课程设计报告2025.1
17 end
18 else begin
19 col<=col+1'b1;//如果没有，就把对应的列加一
20 end
21 end
22 else begin
23 cnt_50_col <= cnt_50_col + 1'b1;//如果纵向没有50个像素，但是走完了一行，那么纵向计数加一
24 end
25 end
26 else begin
27 row <= row + 1'b1;//如果没有走到最后一行，那么行计数加一
28 end
29 end
30 else begin
31 cnt_50_raw <= cnt_50_raw + 1'b1;//如果横向没有走过50个像素，那么横向计数加一
32 end
33 end
34 end
3.2.4 游戏界面文字、数字显示的实现
游戏界面除了贪吃蛇与食物外，还需要显示游戏名称、游戏得分、游戏难度等，这就需要利用
VGA 时序显示文字与数字。
字符（包括汉字、字母和符号等）的本质是点阵，在VGA 屏幕上体现为字符显示区域内像素
点的集合。字符的大小决定了字符显示区域内像素点的数目，而字符的样式（字体、颜色等）则决
定了各像素点的颜色值。因此，我们在进行字符显示之前，先要对指定的字符进行字符取模，获得
该字符的点阵数据。
为了获得指定字符的点阵数据，就需要对字符进行取模处理，字模的提取可以通过字符取模软
件来实现，我们这里所使用的取模软件为PCtoLCD2002 来提取。接下来以“贪吃蛇”为例子说
明如何取模并显示。字宽、字长决定了显示器上字符的大小，这里选择每个字符的字长× 字宽为
64×64。
图15: 导入字样
当多个字符水平相连时，分开生成字模再显示将浪费资源与时间，所以这里将“贪吃蛇”整体
导出后重新打开，再生成字模。
11
李远政、刘振豪华中科技大学数字课程设计报告2025.1
图16: 进行字模的提取
在生成字模的设置中，点阵格式选择阴码；取模方式选择逐行式（与VGA 行列扫描相同）；每
行显示数据中点阵与索引决定了生成字模的横纵数量，这与字符的实际横高需要保持一致，每个汉
字的点大小为64×64，由于每8 个点作为一个字节，则每个字的点阵× 索引为8×8（每个数字点
大小为32×64，点阵× 索引为4×8），这里“贪吃蛇”则为24×8，即点阵为24，索引为8。
图17: 坐标映射计数器计数原理
生成字模后以数组形式储存: 下面展示一段字符的代码：
1 always @(posedge vpg_pclk) begin
2 char0 [0] <= 32'h00000000;
3 char0 [1] <= 32'h00000000;
4 char0 [2] <= 32'h00000000;
5 char0 [3] <= 32'h00000000;
6 char0 [4] <= 32'h00000000;
7 char0 [5] <= 32'h00000000;
8 char0 [6] <= 32'h00000000;
9 char0 [7] <= 32'h00000000;
10 char0 [8] <= 32'h00000000;
11 char0 [9] <= 32'h00000000;
12 char0 [10] <= 32'h00000000;
13 char0 [11] <= 32'h0007E000;
14 char0 [12] <= 32'h001FF800;
15 char0 [13] <= 32'h003C1E00;
16 char0 [14] <= 32'h00700F00;
17 char0 [15] <= 32'h00E00700;
18 char0 [16] <= 32'h01E00380;
12
李远政、刘振豪华中科技大学数字课程设计报告2025.1
19 char0 [17] <= 32'h03C003C0;
20 char0 [18] <= 32'h03C001C0;
21 char0 [19] <= 32'h078001E0;
22 char0 [20] <= 32'h078000E0;
23 char0 [21] <= 32'h070000E0;
24 char0 [22] <= 32'h0F0000F0;
25 char0 [23] <= 32'h0F0000F0;
26 char0 [24] <= 32'h0F0000F0;
27 char0 [25] <= 32'h0F000070;
28 char0 [26] <= 32'h1E000078;
29 char0 [27] <= 32'h1E000078;
30 char0 [28] <= 32'h1E000078;
31 char0 [29] <= 32'h1E000078;
32 char0 [30] <= 32'h1E000078;
33 char0 [31] <= 32'h1E000078;
34 char0 [32] <= 32'h1E000078;
35 char0 [33] <= 32'h1E000078;
36 char0 [34] <= 32'h1E000078;
37 char0 [35] <= 32'h1E000078;
38 char0 [36] <= 32'h1E000078;
39 char0 [37] <= 32'h1E000078;
40 char0 [38] <= 32'h1E000078;
41 char0 [39] <= 32'h1E000078;
42 char0 [40] <= 32'h0F000070;
43 char0 [41] <= 32'h0F0000F0;
44 char0 [42] <= 32'h0F0000F0;
45 char0 [43] <= 32'h0F0000F0;
46 char0 [44] <= 32'h070000E0;
47 char0 [45] <= 32'h078001E0;
48 char0 [46] <= 32'h078001E0;
49 char0 [47] <= 32'h03C001C0;
50 char0 [48] <= 32'h03C003C0;
51 char0 [49] <= 32'h01E00380;
52 char0 [50] <= 32'h00E00700;
53 char0 [51] <= 32'h00700F00;
54 char0 [52] <= 32'h003C1E00;
55 char0 [53] <= 32'h001FF800;
56 char0 [54] <= 32'h0007E000;
57 char0 [55] <= 32'h00000000;
58 char0 [56] <= 32'h00000000;
59 char0 [57] <= 32'h00000000;
60 char0 [58] <= 32'h00000000;
61 char0 [59] <= 32'h00000000;
62 char0 [60] <= 32'h00000000;
63 char0 [61] <= 32'h00000000;
64 char0 [62] <= 32'h00000000;
65 char0 [63] <= 32'h00000000;
66 end
在上面操作中，利用取模软件生成了要显示字符的字模，字模点阵的大小为196*64，下面利用
13
李远政、刘振豪华中科技大学数字课程设计报告2025.1
字模点阵进行字符显示：
首先确定字符有效显示区域，区域大小与字符点阵大小相同，显示区域的像素点与字模点阵中
数据项一一对应，当字模点阵中的数据项数值为“1”时，赋值字符颜色给对应像素点；当字模点
阵中的数据项数值为“0”时，赋值点阵背景颜色给对应像素点。所以为了确定字符点阵显示区域，
声明两个变量char_x、char_y，两变量组成字符点阵显示区域坐标，在字符点阵有效显示区域内，
char_x 信号0-195 循环计数，char_y 信号0-63 循环计数，根据坐标(char_x,char_y) 寻找字符点
阵对应的数据项，根据数据项的数值，赋予对应坐标像素点颜色信息。
1 assign char_x_snake = ((( cnt_h >= CHAR_B_H_snake)&&( cnt_h < (CHAR_B_H_snake
+ CHAR_W_snake)))&&(( cnt_v >= CHAR_B_V_snake)&&( cnt_v < (
CHAR_B_V_snake + CHAR_H_snake))))? (cnt_h - CHAR_B_H_snake) : 10'h3ff;
2 assign char_y_snake = ((( cnt_h >= CHAR_B_H_snake)&&( cnt_h < (CHAR_B_H_snake
+ CHAR_W_snake)))&&(( cnt_v >= CHAR_B_V_snake)&&( cnt_v < (
CHAR_B_V_snake + CHAR_H_snake))))? (cnt_v - CHAR_B_H_snake) : 10'h3ff;
代码解释：如果当前坐标(cnt_h, cnt_v) 在字符区域内，char_x_snake 和char_y_snake 将分别
赋值为：
• cnt_h - CHAR_B_H_snake（表示相对于字符区域左边界的水平位置）
• cnt_v - CHAR_B_V_snake（表示相对于字符区域上边界的垂直位置）
显示代码：
1 if((( cnt_h >= CHAR_B_H_snake -1) &&( cnt_h < (CHAR_B_H_snake + CHAR_W_snake -1)))&&((
cnt_v >= CHAR_B_V_snake)&&( cnt_v < (CHAR_B_V_snake + CHAR_H_snake)))&&(
char_snake[char_y_snake +15][192 - char_x_snake] == 1'b1))begin
2 rgb <= 24'hFFFFFF;
3 end
图18: 坐标映射计数器计数原理
3.2.5 VGA 转HDMI 的编码
该部分使用板卡例程，不过多展示，这里仅说明整体架构：VGA 信号产生模块已经可以产生
每个像素对应的RGB 信号，而并行转串行模块的主要功能就是实现8b/10b 并行串行转换、单端
信号转差分信号、单沿采样转双沿采样。以此得到HDMI 中每一个引脚的电平值。
14
李远政、刘振豪华中科技大学数字课程设计报告2025.1
图19: HDMI 编码模块
3.3 人机交互逻辑的实现
3.3.1 串口屏的界面设计
如图，串口屏设计两个页面，第一个页面用于控制游戏状态和蛇头的移动方向，第二个页面用
于进行难度选择。每个按键按下时可通过串口向ZYNQ7020 发送数据，ZYNQ 接受后根据不同数
据执行不同指令。
这里使用串口屏完美解决了微相开发板按键资源不足的问题，且串口通信协议作为标准化接口
通信协议，可以直接使用电脑进行调试。串口屏的使用让我们简单快捷地实现了人机交互。
图20: 串口屏方向控制界面图21: 串口屏难度选择界面
3.3.2 FPGA 的串口驱动
图22: 串口收发数据标准
按照上图所示的串口通信标准进行串口驱动的设计(主要为接收模块，发送模块后来未调用)：
15
李远政、刘振豪华中科技大学数字课程设计报告2025.1
首先约定波特率为9600（可变），无校验位。将数据线打两拍，防止亚稳态并捕获其的下降沿
信号（起始位0）。检测到下降沿后拉高数据传输标志，意味着数据开始接收；并在传输第九个数据
（终止位1）的正中（数据比较稳定）将数据传输标志拉低，意味着数据接收完成。对时钟进行计数，
每一个周期（在设定波特率条件下传输一位所需要的时间）对数据线进行采样并将数据寄存，同时
记录传输个数（记录当前共接收了多少个数据），接收到第九个数据（终止位1）后，拉高接收完成
标志位。
表4: 用于串口通信的端口
端口名称数据类型作用
sys_clk input wire 50M 系统时钟
sys_rst_n input wire 系统复位
uart_rxd input wire 接收数据线
uart_rx_done output reg 数据接收完成标志
uart_rx_data output reg[7:0] 接收到的数据
direction output reg [2:0] 蛇头运动方向
mode output reg [1:0] 难度模式选择
rst1 output reg 重新游戏标志
pause output reg 暂停游戏标志
16
